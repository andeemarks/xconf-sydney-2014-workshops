; vim: filetype=clojure

(logging/init :file "/var/log/riemann/riemann.log")

; everything is available on the public interface
; probably not the best idea for a production system
(tcp-server :host "0.0.0.0")
(udp-server :host "0.0.0.0")
(ws-server :host "0.0.0.0")
(repl-server :host "0.0.0.0")

(periodically-expire 10)

(let [client (tcp-client)
  ; Keep events for 5 minutes by default
  index (default :ttl 300 (update-index (index)))]

  (streams
    (with {:metric_f 1 :host nil :state "ok" :service "events/sec"}
      (rate 5 index))

    (where (service #"^per")
      (percentiles 5 [0 0.5 0.95 0.99 1]
        index))
    ; Log expired events.
    (expired
      (fn [event] (info "expired" event)))

  ; calculate the number hosts sending events to us
	(with :service "distinct hosts"
		; combine each host and service into a stream
		(coalesce
			(smap (fn [events] 
				(let [c (count events)] (riemann.common/event {:metric c :host "all" :service "host count" })))
			 index)))

	; get percentage cpu utilization for each host
  ;
	; filter cpu services - cpu 0 for now
	(where (service #"^cpu-0")
		; split them by host - for each host
		(by :host 
			; send a vector of events out every 60 seconds
			(coalesce
        ; smap passes those events into a function
        (smap (fn [events]
          ; cpu utilization percentage
          (let [cpu-util (/(* 100 
                              (:metric (riemann.folds/sum (filter #(not= "cpu-0/cpu-idle" (:service %)) events))))
                          (reduce + (map #(:metric %) events)))
                host (:host (first events)) ]
            (riemann.common/event {:metric cpu-util :service "cpu utilization" :host host }))) index))))
	index


))

; logging for debugging

; print events to the log
;(streams
;  prn)

; print only streams from 'cpu' - jiffies spent in user mode - clean logging
;(instrumentation {:enabled? false})
;(streams
;  (where (service #"cpu") prn)
;)

